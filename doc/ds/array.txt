陣列
----

陣列一組序對<索引,值>的集合，
索引為一個整數，而值則為任意物件。
索引可用來取存放特定的值。

如下表為一個用來儲存前 5 個質數的序列：

0 2
1 3
2 5
3 7
4 11

第一列為索引，第二列為值。
像是索引 1 可存取 2 這個質數，
索引 2 可存取 11 這個質數，
利用陣列可以將物件集合使用簡單的整數來組織。

記憶體
......

現代電腦記憶體可視為一個超大型的同質有限隨機存取位元組陣列，
每個位址即為索引，可存取到一個 8 位元的位元組，
同質指得是記憶體中可存取每個元素都是一樣類型，即 8 位元的位元組，
有限指記憶體元素量是有上限的不是無限的，
像 32 位元的電腦指位址有 32 位元長，
故最多能支援到有 2^32 位元組的記憶體，大約 4 GB。

記憶體的重要特色是隨機存取(Random Access)，
指的是當記憶體中的訊息被讀取或寫入時，
所需要的時間與這段資訊所在的位置無關，
相對地鏈結串列結構、順序存取記憶體（磁帶）、
直接存取記憶體（磁碟），
索引大的資料比索引小的資料要花較多的時間存取。

連續記憶體區塊實作陣列
......................

若用連續記憶體區塊實作陣列，
則可於常數時間完成元素存取操作。
但是仍要符合同質有限的限制，
意指陣列只能存放同類型的元素，
同類型通常指陣列元素所佔用的記憶體長度一樣，
且因為記憶體長度有限，故只能存放有限的元素。

記憶體位址是索引，每個位址可存取 1 位元組(8位元)的資料，

以連續記憶體區塊實作陣列是將連續區塊分為以元素型態長度分成數個槽，
每個槽可用來存放元素資料。 

陣列初始
++++++++

陣列初始程序如下：

1.系統依使用者給定陣列元素的型態長度，
  以及陣列元素數目，求出陣列需求的記憶體長度公式如下：
  陣列記憶體長度 = 槽長度 * 槽數目
2.系統從記憶體中找到空閒的儲存區塊，
  配置給此陣列並把區塊起始位址作為陣列基底位址。

C 的陣列建構式語法如下：

weeks = {"SU","MO","TU","WE","TH","FR","SA"}

上式建構 weeks 的 Array 物件，
依序將組成字串，於方括號中依逗號分隔列出，
而索引值則由 0 起計，每右移一個的物件則加 1。
如"SU" 在第 1 個位置，其索引值預設為 0；
"TU" 在第 3 個位置，其索引值預設為 2。

索引存取
++++++++

索引取值運算為一個一元運算，
其接受一個索引，並傳回索引指示的元素。
當使用者利用索引存取元素時，
則使用基底位址及槽長度求出索引所指定的槽的起始位址，
並利用起始位址存取槽內的元素，槽起始位址算法如下：

  槽起始位址 = 陣列起始位址 + 槽長度 * 索引值

大部份程式語言都以 Array[index] 作為索引取值的語法，
其中 index 為索引值。

索引賦值表示將右值設為索引的對應值，
大部份程式語言都以 Array[index]=rvalue 作為索引賦值的語法，
其中 index 為索引值，而 rvalue 為所要存放到槽中的新值。

/* array_memory.c */
#include <stdio.h>

void main(void) {
    int i;
    int a[5] = {2, 3, 5, 7, 11};
    for(i=0;i<5;i++)
       printf("%p %i\n", &a[i], a[i]);
}

上面 c 程式會印出 5 個整數陣列的位址如下：

0060FEE8 2
0060FEEC 3
0060FEF0 5
0060FEF4 7
0060FEF8 11

從上表可以看到這個陣列起始位址為 0060FEE8，
由相鄰槽位址差距 0060FEEC - 0060FEE8 = 4，
可得陣列每個槽長度為 4 個位元組，
表示機器上每個 int 型別佔 4 個位元組。

排序陣列
........

由於陣列的索引為連續整數值，
所以如所示，
則要在陣列的 A 及 B 間插入一元素 D，
必須先移動 C 到新配置空間，
再把 B 移動到原來 C 的空間，
再將 D 放到 B 的空間，
因此若陣列的長度為 n，
插入一個元素在最壞的情形下，
必須移動 n 個元素。

由於陣列的索引為連續整數值，
所以如所示，
要刪除一元素 D，
先清空 D 的空間，
再移動 B 到 D 的空間，
再把 C 移動到原來 B 的空間，
因此若陣列的長度為 n，
刪除一個元素在最壞的情形下，
必須移動 n-1 個元素。

字串
....

C 的字串是結尾為 '\0' 字元陣列，字元是一個8位元。


矩陣
....

矩陣的 ADT

class Matrix
  initialize(_elem_type, _size)
  [](col, row) 
  []=(col, row, value)
end


不第後賦菊
黃巢



  
		欄/列
    0
    1
    2
		3
		4
		5
		6
	


	0
		待
    到
    秋
    來
    九
    月
    八
	
	1
		我
    花
    開
    後
    百
    花
    殺
	
	2
		衝
    天
    香
    陣
    透
    長
    安
	
	3
		滿
    城
    盡
    帶
    黃
    金
    甲
	






矩陣就是二維陣列，
二維指每個槽需要用二個整數來指定，
分別稱為欄與列。
為用一個 7X4 的矩陣，
來儲存一首 7 言絕句的唐詩，黃巢的『不第後賦菊』。
其存取操作與矩陣相同，
但指定元素時必須傳入欄及列兩個值，
如 poem[3,2] 則取出在表格第 3 欄，
第 2 列位置的字，即為"陣"。

以連續記憶體區塊實作矩陣

用連續 記憶體 區塊實作矩陣，在存取元素的操作效率上可以達到常數時間，
但是必須將矩陣二維位址轉換成一維的 記憶體 位址。
其轉換方法有兩種，分別為列優先及欄優先。


計算列優先槽起始位址

def slot_addr(col, row)
  return @base_addr + @slot_len * [ (row * col_size) + col ]
end


列優先儲存法，
指是是每一列先走完換一行，
其求每個槽起始位址公式如所示。
列優先儲存法



  
		索引
    0
    1
    2
		3
		4
		5
		6
		7
		8
		..
		26
		27
	


	值
		待
    到
    秋
    來
    九
    月
    八
		我
    花
		..
    金
    甲
	




如即為
以列優先儲存法的陣列。


計算欄優先槽起始位址

def slot_addr(col, row)
  return @base_addr + @slot_len * [ (col * row_size) + row ]
end


欄優先儲存法，
指是是每一欄先走完換一列，
其求每個槽起始位址公式如所示。
欄優先儲存法



  
		索引
    0
    1
    2
		3
		4
		5
		..
		26
		27
	


	值
		待
		我
		衝
		滿
    到
    花
		..
    安
    甲
	




如即為
以欄優先儲存法的陣列。


動態陣列
........

當很難估計足夠需求的陣列元素數目，
必須使用動態陣列，其以一個底層陣列儲存元素
當底層陣列大小不足時，底層陣列會自動擴展，
它會自動重新配置一個夠大的底層陣列，
並將舊陣列元素複製到新陣列，並刪除舊陣列。

動態陣列會使用 2 個變數，
第一個為大小，記錄現在總共儲存了元素，
第二個變數為容量，指底層陣列還有多少空間可以儲存元素。

新陣列的大小通常為舊陣列的 1.5 倍，這稱為成長因子，
若成長因子太大會浪費許多記憶體空間且容易造成記憶體不足。

