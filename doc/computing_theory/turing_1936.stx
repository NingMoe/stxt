論可計算數及其在判定問題上之應用
================================

20130211 週一 前鎮娘家

20140907 週日 中美路家

自從認識了Gödel 不完備定理後，
一直對數理邏輯的基礎充滿興趣。

Gödel 不完備定理證明具備一定強度的證明系統，
能產生不能判定為真同時也不能判定為假之定理，
此定理描述了形式證明系統之有限性。

圖靈更進一步的提出計算模型，
自動機，並利用通用機器可將程式以資料。

20140915 週一 中美路家

與丘奇不同的是，
丘奇將 λ 程式用遞迴函數去操作，

而圖靈將機器程式用通用機器去操作，
相當於用 C 語言寫 C 的編譯器，這是空前絕後的創舉。

20141019 週日 中美

而丘奇的論文是植基於克林及許多人的工作上，
才能完成對判定問題無解之證明，
但是圖靈僅在 35 頁的論文內，
就能提出一個通用程序，並應用來證明判定問題無解，
真是令人佩服。

我並非翻譯圖靈的論文，而是讀完很多遍，並理解後，
以中文的思考模式重寫出來，

如原文直譯可能為
「判定問題有解，即是存在一個通用程序判別 Un(M) 是否可證明。」
但「存在」這個詞讓讀者難以意會其真意，若譯為
「判定問題有解，即是可以找到一個通用程序判別 Un(M) 是否可證明。」
這樣大家一定可以很快抓到判定問題之真義，
我是以這樣的態度完成這篇文章。

自動機
------

a 機
....

自動機(automatic machines)指機器之運作完全由狀態決定。

c 機
....

其對比是選擇機(choice machine)，
當運作至模糊狀態時，須由外部操作員作出決定，
機器才能開始運作。

符號
....

機器由兩類符號定義：

數
++

數(figure)僅含 0 及 1 兩種符號，
又稱為第一類符號(symbols of the first kind)。

第二類符號
++++++++++

第二類符號(symbols of the second kind)
是除了 0 及 1 的所有符號，
也就是第一類符號的補集。

符號是有限
..........

自動機之符號是有限的。

機器狀態
........

機器狀態(m-configuration)指機器之內部狀態，
由外界無法觀察到。

利用機器狀態的轉變，
機器可有效的記住之前掃描的符號。

交替格法
........

圖靈把帶子視為F格及E格交替接續，稱為交替格法(alternative squares)。

F 格
++++

F 格用在存放計算出的數字。

E 格
++++

E 格(E squares)指暫存格，E 表示 eraseble。

標示
++++

F 格 S 緊鄰右一個之 E 格，若其符號為α，
則稱 S 以 α 標示mark。

20130215 週五 前鎮

指令表
------

指令表(table)描述機器的行為，
包含一組有限之指令，
故機器之行為可以用有限字元來描述。

每條指令有 4 個欄位：
分別為機器狀態、掃描符號、操作及最終機器狀態，

機器狀態、掃描符號描述狀態，
而操作及最終機器狀態描述行為。

20130317 週日 花蓮 

機器狀態
........

機器狀態包含一組小寫英文字母。

掃描符號
........

符號由英數字組成；
或 None 表任何符號均符合。

操作
....

操作一般由印出符號指令及移動指令組成，可為下列之串列：

Pα 印出符號 α 
E  刪除符號

R  右移
L  左移

I 機 
....

I 機可印出數列 010101....
規則表如下：

b None P0,R c  狀態b命名源自 begin，指開始狀態。
c None    R e
e None P1,R f
f None    R b

簡化表
......

簡化表允許操作可包含多個移動指令。

I 機簡化表
..........

I 機簡化表如下：

b None P0     b
  0    R,R,P1 b
  1    R,R,P0 b

II 機
.....

II 機可印出 001011011101111011111... 之數列。

本文以國際音標  X-SAMPA 的 @ 來表示原文之音標字母。

啟動時 II 機會在紙帶上印出 @@0，之後會在奇數格印出數字，這是交替格法，
@@ 是用來定位用的。

II 機簡化表如下：

b             P@,R,P@,R,P0,R,R,P0,L,L o 以表啟動(begin)之 b 作為啟始狀態

o 1           R,Px,L,L,L              o 將 1 標記 x
  0                                   q           

q Any(0 or 1) R,R                     q 在數列後印出 1
  None        P1,L                    p

p x           E,R                     q 刪除 x 右移轉到 q 再印 1
  @           R                       f
  None        L,L                     p

f Any         R,R                     f
  None        P0,L,L                  o

標準指令表
----------

義仁 20130215 週五 

標準指令表中每條規則有 5 個欄位。

qi Sj Sk M ql 

分別表示機器狀態為 qi 、掃描符號為 Sj，
下一步動作為印出 Sk、移動指令為 M ，機器狀態轉換為 ql。

移動指令 M 有三種情形如下表：
R 右移
L 左移
N 不移動

qi
..

qi 表示第 i 個狀態。

預定狀態如下表：

q1 初始狀態

Si
..

Si 表示第 i 個符號。

預定符號如下表：

表示 符號
S0   空格
S1   0
s2   1

刪除操作
........

刪除操作 E 以 PS0 表示。
如下例：
qi Sj E  ,R qm
qi Sj PS0,R qm

移動操作
........

移動操作以印出掃描符號後移動表示。
如下例：
qi Sj     R qm
qi Sj PSj,R qm

S.D
---

標準描述(Standard Description)
僅含 A, C, D, L, R, N, ; 之符號列，
用來描述機器之指令表。

每條指令以 ; 符號分隔。

R 右移
L 左移
N 不移動
; 分隔指令

標準指令轉換為 S.D
..................

qi 由一個 D 後面重覆 i 個 A 表示。

Sj 由一個 D 後面重覆 j 個 C 表示。

由上述規則可知 D 字元之選用源自英文的分隔字元(Delimiter)。

宿舍 20130317 週日 

D.N
---

Description Number，描述數

S.D 用下面規則所轉成的數列。

A=1
C=2
D=3
L=4
R=5
N=6
;=7

骨架表
------

在骨架表(skeleton table)中，
大寫德文為狀態變數，小寫希臘文為符號變數。

f(C, B, α)
..........

找出第一個(最左邊)之 α 符號，8
若找到狀態轉為 C；沒找到則轉為 B。

命名源自 first。

f (C, B, α) @      L f1(C, B, α)
            not  @ L f (C, B, α)

f1(C, B, α) α        C
            not  α R f1(C, B, α)
            None   R f2(C, B, α)

f2(C, B, α) α        C
            not  α R f1(C, B, α)
            None   R B

e(C, B, α)
..........

刪除第一個 α 符號轉為 C；沒找到則轉為 B。

 e(C, B, α)   f(e1(C, B, α), B, α)
e1(C, B, α) E C

e(B, α) 刪除所有 α 符號轉為 B。

 e(B, α)      e( e(B, α)   , B, α) 

e(C) 刪除所有標記。

 e(C) @     R     e1(C)
      Not @ L      e(C)

e1(C) Any   R,E,R e1(C)
      None        C

機器狀態變數
............

e(C, B, α)中，C 及 B為狀態變數，α 為符號變數，
e 則稱為機器狀態變數(m-configuration functions)，
簡寫為 m-函數(m-functions)，表示任一個機器狀態。

設某個機器的 m-狀態有 e(b,x) 或以 q 表示 e(b,x)，
則命令行如下：

e(b,x)      e(e(b,x),b,x)

或是

q           e(q     ,b,x)

完整的規則表應出現下列規則：

q           e(q        ,b,x)
e(q,b,x)    f(e1(q,b,x),b,x)
e1(q,b,x) E q

若再以q' 取代 e(q,b,x)，
並利用取代得出表示 m-狀態函數 f 之表，
則可得不具任何 m-狀態函數之規則表。 

pe(C,β)
.......

從狀態 pe(C,β) 開始，
機器於數列尾端印出 β 後轉入狀態 C。 

命名源自 print at end。

 pe(C,β)            f(pe1(C,β),C,@)
pe1(C,β)   Any  R,R pe1(C,β)
           None pβ  C

從狀態 pe2(C,α,β) 開始，
機器於數列尾端印出 α 及 β 後轉入狀態 C。 

pe2(C,α,β)          pe(pe(C,β),α) 

l(C) 與 r(C)
............

l(C) L C 左移一格，命名源自 left。

r(C) R C 右移一格，命名源自 right。

f'(C, B, α) 與 f''(C, B, α)
...........................

f' 同 f，但是在轉移至 B 前，會先左移一格。
f'' 則會先右移一格

f' (C, B, α)   f(l(C), B, α)
f''(C, B, α)   f(r(C), B, α)

c(C, B, α)
..........

找出第一個標記為 α 的符號 β，並於數列尾端印出 β。

c 源自於複製之英文，copy。

最後一行的轉成表必須每個機器可印之符號，
取代 β 並形一個新的指令。

 c(C, B, α)   f'(c1(C),B,α) 移到第一個標記為 α 的符號 β。
c1(C      ) β pe(C,β)       於尾端印出 β

ce(B,α)
.......

將所有標記為 α 的符號於數列尾端印出，並清除標記 α。

ce 源自於複製並清除標記之英文，copy and erase。

 ce(B,  α) ce(ce(B,α),B,α)
 
 ce(C,B,α) c(e(C,B,α),B,α) 找出第一個標記為 α 的符號，
                           並於數列尾端印出，再刪除第一個符號標記。

標記為 α 的符號於數列尾端印出，
再將標記為 β 的符號於數列尾端印出，並清除標記 α 及 β。

ce2(B,α,β) ce(ce(B,β),α)   
                          
標記為 α 的符號於數列尾端印出，
再將標記為 β 的符號於數列尾端印出，
最後將標記為 γ 的符號於數列尾端印出，
並清除標記 α、β 及 γ。

ce3(B,α,β,γ) ce(ce2(B,β,γ),α)   

re(B, α, β)
...........

將所有符號 α 以 β 取代。

命名源自取代之英文 replace。

 re(B,α,β)         re(re(B,α,β),B,α,β)

 re(C,B,α,β) E,Pβ f(re1(C,B,α,β),B,α)  將第一個符號 α 以 β 取代。
re1(C,B,α,β) E,Pβ C

cr(B,α)
.......

cr(B,α) 將所有標記為 α 的符號於數列尾端印出，但不清除標記 α。

20140915 週一 中美路

命名應源自印在右邊 copy right。

cr(C,B,α) c(re(C,B,α,β),B,α)        找出第一個標記為 α 的符號γ，
                                    並於數列尾端印出 γ，
                                    再將標記 α 用 β 取代。
cr(B,α)   cr(cr(B,α),re(B,β,α),α)   所有標記為 α 的符號於數列尾端印出，
                                    再將標記 β 還原成 α。
cp(C,A,E,α,β)
............

比較第一個 α 標記之符號 γ 及第一個 β 標記之符號 δ，
若符號相同則轉入狀態 C，符號不同或只有沒有α標記符號則轉入 A，
沒有 α 或 β 標記之符號則轉入 E。

 cp(C,A,E,α,β)       f'(cp1(C,A,β), f(A,E,β), α)
cp1(C,A,    β) γ     f'(cp2(C,A,γ), A       , β)

cp2(C,A,    γ) γ     C
               not γ A

cpe(C,A,E,α,β)
..............

cpe 與 cp 不同在於，比較第一個 α 標記之符號 γ 及第一個 β 標記之符號 δ，
若符號相同則轉入刪除 γ 及 δ 。

命名源自比較及刪除(compare and erase)。

cpe(C,A,E,α,β) cp(e(e(C,C,β),C,α),A,E,α,β)

比較 α 標記之數列 Sα 及 β 標記之數列 Sβ，
若相同則進入 E，其餘情形進入 A，
一些 α 及 β 會被刪除。

cpe(A,E,α,β) cpe(cpe(A,E,α,β),A,E,α,β)

g(C, α)
.......

找最後一個符號 α，
若找到後轉入 C。

命名應源自 go。

g (C)    Any   R g (C)       移到最後一格，並轉移至狀態 C。
         None  R g1(C)

g1(C)    Any   R g (C)
         None  R C

g (C, α)         g(g1(C, α)) 先移到最後一格，再往回找符號 α

g1(C, α) α       C           往回找符號 α
         not α L g1(C, α)

計算機
------

只能印出第一類及第二類符號的自動機稱為計算機(computing machine)。

circular{p.233}
...............

circular 機器會進入某個狀態，
此狀態不是停機，就是機器只能不斷印出第二類符號。

circle-free{p.233}
..................

機器能不斷印出數字。

序列
....

數字序列，簡稱為序列，或數列(figures)。

機器計算之數列
..............

由一台圖靈機所印出的數列稱作
機器計算之數列(sequence computed by the machine)。

S(M)
....

非論文，由我所加的定義。

義仁老家 20130214 週四 

S(M) 表示由機器 M 所印出的數列。

機器計算之數字
..............

機器計算之數字(number computed by the machine)為
其計算之數列前加一個小數點所表示之實數。

可計算數列
..........

可計算數列(computable sequence)為能由一台 circle-free 機器所印出的數列。

因為每個可計算數列至少對應一個 D.N，
而沒有 D.N 可對應 2 個以上之可計算數列，
所以可計算數列是可列舉的。

可計算數
........

可計算數(computable number)為其數字能由一台機器所印出的數列，
其不包括所有可定義之數，但不可列舉。

花蓮 20130219 週二 

滿足數
......

一個 circle-free 之機器之 D.N。

本論文證明沒有一般方法可決定數字 n 是否為滿足數。

M(n)
....

表示機器 M 其 D.N 為 n。
 
U 機
----

U 表示通用機器，
在磁帶開始置入任一機器 M 之 S.D，
則 U 可印出和 M 一樣的數序。

這項創舉讓程式表示和資料都可放在同一個紙帶中。

完整狀態
........

完整狀態(complete configuration)包含當時紙帶上所有的符號，
並將狀態列於掃描符號之下。

2 個接續的完整狀態以冒號 ":" 分隔
(本文@為X-SAMPA的國際音標來表示原文之字母)。

 :@@0 0:@@0 0:@@0 0:@@0 0   :@@0 0 1:
b   o     q       q        q      p

花蓮 20130219 週二 

C 機
....

除了將狀態列於掃描符號之下，
也可掃描符號左方插入一格，並填入機器狀態。
如數列 C：

b:@@o0 0:@@q0 0:... (C)

第二種寫法可於一行記下所有完整狀態，
有理論上之用途。

D.N 表示法
..........

把機器狀態及符號轉成 D.N，
其中機器狀態 o 以 DAA、q 以 DAAA 取代，
而符號 @ 以 DCCC 取代可得表示完整狀態之數列 C1 如下：

DA:DCCCDCCCDAADCDDC:DCCCDCCCDAAADCDDC:... (C1)

M'
..

M' 可於 F 格接續印出完整狀態。

U 可印的符號
............

20130221 週四 花蓮 

U 可印的符號如下表：

A
C
D
0
1
u 標記關聯完整狀態之指令印出之符號
v 標記最後完整狀態之狀態前一符號之前的符號列
w 標記最後完整狀態之狀態之後的符號列
x 標記最後完整狀態之狀態前一符號
y 標記關聯完整狀態之指令之最終機器狀態
z

b
.

b 在 "::" 後印出 :DA 表示初始狀態，後轉入 anf 狀態。

b                       f(b1, b1, ::)
b1 R,R,P:,R,R,PD,R,R,PA anf

anf
...

anf 命名源自德文 anfangen 表示啟動。

把最後一個完整狀態的狀態標記為 y，
再轉移至 kom。

長遠看來，anf 會找到最後一個完整狀態關聯的指令，
之後可由標記為 z 的分號，找到指令。
並轉移至 sim。

anf   g  (anf1, :)
anf1  con(kom, y)

kom
...

kom 命名源自德文 komparation 表示比較。

kom 找到最後一個沒有標記 z 之分號 ";" ，
把它標記為 z，並把之後的狀態標記為 x。

等同於把指令表最後一個沒有標記 z 指令的分隔號標為 z，
狀態標為 x。

kom ;           R, Pz, L con(kmp, x)
    z           L, L     kom
    not z nor ; L        kom

kmp
...

比較 x 所標記的指令之狀態，
及 y 所標記的完整狀態之狀態，
若一樣則轉移 sim，其它則轉移至 kom。

再去除 x 及 y。

kmp cpe(c(kom, x, y), sim, x, y)

sim
...

將要執行的指令之操作標為 u，
而要轉換之狀態標為 y，
再清除 z 標記。 

再進入 mk。

sim                   f'(sim1, sim1, z)

sim1                  con(sim2,)

sim2 A                sim3              
     not A R,Pu,R,R,R sim2               若不是 A 則為操作字元，
                                         標記 u。
                                   
sim3 not A L,Py       e(f, z)            
     A     L,Py,R,R,R sim3               若是 A 則是轉換狀態，標為 y。

mk
..

完整狀態被分為 4 部份，

狀態部份不標記，狀態前一符號以 x 標記，
狀態前一符號之前的符號串列第一部分以 v 標記，
狀態之後的符號串列以 w 標記。

最後印出 ":"，再轉移至 sh。

命名源自標記 mark。

mk                   g(mk1, :)

mk1 not A R,R        mk1
    A     L,L,L,L    mk2

mk2 C     R,Px,L,L,L mk2
    :                mk4
    D     R,Px,L,L,L mk3

mk3 not : R,Pv,L,L,L mk3
    :                mk4

mk4                  con(r(r(mk5)),)

mk5 any   R,Pw,R     mk5
    None  P:         sh

:DCCCDCCDAADCDDC

會被 mk 標記成

:DCCCDCCDAADCDDC:
 vvvvxxx     www

sh
..

花蓮 20130222 週五 

找到 u 標記的印出符號指令，
並於尾端印出 0: 或 1: 之符號。

sh                f(sh1,inst,u)

sh1       L,L,L   sh2

sh2 D     R,R,R,R sh2
    not D         inst

sh3 C     R,R     sh4
    not C         inst

sh4 C     R,R     sh5
    not C         pe2(inst,0,:)

sh5 C             inst
    not C         pe2(inst,1,:)

inst
....

20130223 週六 花蓮  

inst 名稱源自 instruction，
會執行標記之指令，後寫下下一個完整狀態。

inst           g(l(inst1),u)

inst1    α R,E inst1(α)

inst1(L)       ce5(oo,v,y,x,u,w)

inst1(R)       ce5(oo,v,x,u,y,w)

inst1(N)       ce5(oo,v,x,y,u,w)

ov             e(anf)            命名源自英文結束(over)

可計算數列是不可列舉的
----------------------

20141019 週日 中美

對角線法證明可計算數列是不可列舉
................................

我們以康託用來證明實數不可列舉之對角線法來證明可計算數列是不可列舉。

證明：

假設可計算數列是可列舉的，可作以下定義。

義仁 20130213 週三

令 αn    表示第 n 個可計算數列。
   φn(m) 表示第 n 個可計算數列中第 m 個數字。
   β 數列其第 n 個數字為 1 - φn(n)。
   (β 源自其為 α 之定義後。)

設 β 數列是可計算的，且為第 K 個可計算數列，
則下式成立：

1 - φn(n) = φK(n)

令 n = K 則

1 - φn(n) = φn(n)

可得

1 = 2φn(n)

因為 1 不可能為偶數，故 β 數列不可計算

此證明之缺點在於假設 β 數列是可計算的。

直觀而言，若能以有限步驟完全列舉可計算數列，
即可計算出 β 數列。

能以有限步驟完全列舉可計算數列，
即是存在一個通用程序(general process)能於有限步驟內去判定某數是否為滿足數，
即某數是否為非循環機器之 D.N。

此通用程序之存在，
即是否能以建構一機器來判定任一機器是否為非循環機。

定理 II 
.......

20141018 週六 中美

不存在機器能判定任一機器是否為非循環機。

證明大綱：

1.設存在非循環機 D 可判定給定 S.D 是否為可滿足數。

2.令數列 β' 第 n 個數字為 φn(n)，
  即第 n 個可計算數列之第 n 位數。

3.令機器 H 表示能計算出 β' 之機器。

4.利用 D 來建構機器 H，由 H 之建構方式可知 H 為非循環機。

5.令 K 為 H 之 D.N。

6.因 H 無法計算至 R(K) 之數，故 H 為非循環機。

7.由 H 之建構可知 D 為循環機。

8.證明結束。

證明：

令機器 D 表示一機器，
若給定一 S.D，即可判定此 S.D 是否為非循環機。

若為循環機之 S.D 則將其標記 u，
表示不可滿足(u 源自 unsatisfactory)；

若為非循環機之 S.D 則將其標記 s，
表示可滿足(s 源自 satisfactory)。

在此先假設 D 是循環機。

令數列 β' 第 n 個數字為 φn(n)，即第 n 個可計算數列之第 n 位數。
(φn(m) 表示第 n 個可計算數列中第 m 個數字。)
(β' 名來自定義於 β 之後)

令機器 H 表示一機器可計算 β'。 

可組合 D 及 U 來建構 H 如下：

H 會以 1, 2, 3, .. , N-1, N, ... 
等遞增方式列舉數字，
列舉的每一步會作下列處理：

設此步驟已列舉至 N ，
H 會先用 D 去判斷該數字 N 是否為滿足數，

若為滿足數，則 R(N) = R(N-1) + 1，
並將 N 轉成 S.D 再用 U 模擬 M(N) 印出其所計算之數列至第 R(N) 個數字，
再把第 R(N) 個數字附加到 β' 數列。

若不為滿足數時，則 R(N) = R(N-1)，
並進行下一步列舉 N + 1。

由上可知，R(N) 這個函數用來表示數字 N 內，已有幾個可計算數。

H 運作如下虛擬碼：

N = 0
R = 0
do 
    N = N+1
    if D(N) == s then
        R     = R + 1    
        β'Rth = U(N)[R]
        β'    = β' . β'Rth
loop

由上虛擬碼可知 H 之計算能在有限步驟完成，
故其為非循環機器。

可令 K 為 H 之 D.N，
因為 H 為非循環機，故 K 應為滿足數，其不能標記為 "u"，
但由下知 K 也不能被標記為 "s"：

當 H 進行至第 K 步驟時，
因為 K 為可滿足數，
故 H 會利用 U 模擬 M(K) 來計算至第 R(K) 位數字。

因為 M(K) = H，
使得 U 又重新計算 H 之第 R(K) 位數字。

H 在第 K 步驟一直循環反復於計算第 R(K) 位數字中，
使得第 R(K) 個數字永遠無法找到，
而 H 無法再印出任何數字，故圖靈稱此種機器為循環機(circular)。

由前述 H 之建構過程，可知 D 為循環機。

定理 III
--------

20141018 週六 中美

不存在機器判定另一機器是否會印出 0。

證明大綱：

1.假設可判定 M 是否印出 0 之機器 E 存在。
  E 之名源自判定之德文entscheiden。

2.建構機器 Mi 其會把前 i 個 0 改成 ō。 

3.建構機器 F 會依序印出 Mi 之 S.D。

4.建構機器 G 其會判定 M 是否永遠印出 0。

5.利用 E 判定 G，

證明：

20130214 週四 義仁
20141019 週日 中美

令 E 表示一機器，其可判定 M 是否會印出 0，
並假設 E 為非循環機。

設 M 為任一機器，
並可衍生機器 Mi 如下：

M1 會將 M 所計算之數列 S(M) 前 1 個 0 改成 Ō，
M2 會將 M 所計算之數列 S(M) 前 2 個 0 改成 Ō。
Mi 會將 M 所計算之數列 S(M) 前 i 個 0 改成 Ō。

假設 M 印出下面的數列。
M  = ...AB01AB0010AB...  則 Mi 會印出
M1 = ...ABŌ1AB0010AB...
M2 = ...ABŌ1ABŌ010AB...
M3 = ...ABŌ1ABŌŌ10AB...
M4 = ...ABŌ1ABŌŌ1ŌAB...

令 F 表示一機器，給定任何機器 M 之 S.D，
其能依序印出 M1, M2, ... 之 S.D。

我們以 E、F 及 Mi 來建構機器 G，
其能接受任一機器 M 之 S.D，
再用 E 測試 M 是否永遠不印出 0，
若為真則印出 :0:，否則不作任何事。

下一步則用 F 輸出 M1 之 S.D，
再用 E 測試 M1 是否永遠不印出 0，
若為真則印出 :0:，否則不作任何事。
對所有 Mi 反覆進行此程序。 

G(M):
    若 D(M) 永遠不印出 0 則
        印出 ":0:" 
    反覆
        Mi := F
        若 D(Mi) 永遠不印出 0 則
            印出 ":0:"
    執行 

若 M 不會印出 0 或只是印出有限的 0，則 G 會不停的印出 0；
若 M 永遠印出 0，則 G 永遠不印任何數字。

20130214 週四 前鎮

若 E 判定 G 永遠不會印出 0，
即 M 會永遠的印出 0。

若 E 判定 G 有時會印出 0，
即 M 不會永遠的印出 0。

定義機器 G' 如下：
若 M 不會印出 1 或只是印出有限的 1，則 G' 會不停的印出 0；
若 M 永遠印出 1，則 G' 永遠不印任何數字。

E 判定 G' 永遠不會印出 1，
即 M 會永遠的印出 1。

E 判定 G' 會印出 1，
即 M 不會永遠的印出 1。

結合 E(G) 及 E(G') 可得出判定 M 是否為非循環之機器。

由定理 I 知能判定 M 是否為非循環機器不存在，
依歸謬法可知 E 不存在。

簡單操作
--------

簡單操作只能改變正觀察到之方格符號。

直接辨識
........

直接辨識(immediately recognisable)指正掃描的數字，
或被單一符號標示之數列。

如以下數列：
1u2u3u4v5v6v

123 被 u標示，視為一組；456被v標示視為一組可直接辨識之數列。

利用函數計算定義可計算函數
--------------------------

20130317 週日 宿舍 

若將希爾伯特之函數計算(functional calculus)修正比較系統化，
且只只用有限符號，則可建置一個自動機 K 找出所有可證明之公式。

F(x,y)
......

20130215 週五 前鎮

後繼函數，繼承 Gödel 1930 年論文之用法，
命名源自德文 folgend。

20141018 週六 中美

y 為 x 之直接後繼數。

F(x, y) <-> y == x + 1

N(x)
....

令 N(x) 為 x 為是否為非負整數。

P
..

命名源自皮亞諾公理，定義如下： 

  (E u)N(u) 
& (x)(N(x) -> (Ey) F(x,y))  若 x 為非負整數，必有 y 為其後繼數
& (F(x,y)  -> N(y))         若 y 為 x 之後繼數，y 必為非負整數。

皮亞諾公自然數的五條公理
i.  0是一個自然數。
ii. 0不是任何其他自然數的繼數。
iii.每一個自然數a都有一個繼數。
iv. 如果a與b的繼數相等則a與b亦相等。
v.  若一個由自然數組成的集合s包含有0，又若當s包含有某一數a時，
    它一定也含有a的繼數，則s就包含有全體自然數。

Gα(x)
.....

設 α 是一數列，Gα(x) 指 α 的第 x 位數字為 1。
-Gα(x) 指 α 的第 x 位數字為 0。

A 定義 α
........

可以利用 Gα、N 與 P 之合取來建構一個公理 A，此公理定義了 α。

若公理 A 定義 α，
指 -A 不是可被證明的公式，
且對每個 n 而言，An 或 Bn 其中之一可被證明。

An
..

A & F^(n) ->  Gα(u^n)           (An)

Bn
..

A & F^(n) -> -Gα(u^n)           (Bn)

^(r)
....

r 個角分符號 ' 序列。

原文註解為 A sequence of r primes is denoted by (r)，
之前誤解為質數序列。

角分符號被稱作 prime 源於誤讀。

因為在20世紀初期，
x' 被讀作 x prime 並不是因為在 x 後跟著一個 prime symbol，
而是因為變數列 x', x'', x''' 讀作
x prime, x second,  x third，
prime 是「最初的」意思，而非角分符號之讀音。

後來在1950s與1960s年代，術語 prime 開始用於撇號這一類的符號。
使得現在 x'' 與 x''' 
在英文中通常讀作 x double prime 與 x triple prime。

F^(n)
.....

F^(n) = F(u, u') & F(u', u'') & F(u'', u''') &...

u 可視為起始數，通常代表 0。

K 機
....

將 Hilbert 之函數計算(functional calculus)，限定成使用有限符號，
則可使用自動機 K 找到所有於函數計算中可證明之公式。

Kα 機
.....

令 α 為可計算數列，Kα 機能計算出 α。

Kα 機分成 n 個階段，
在第 n 個階段中，會找出 α 的第 n 個數字。

第 n-1 個階段結束時，會印出雙引號 :: 於結尾。
第 n 個階段中執行所印出之符號都會在雙引號之右邊，
機器會執行以下之動作

i.   印出 A 後再印出公式 An 。

ii.  印出 B 後再印出公式 Bn。 

iii. 如同 K 機，開始尋找可證明之公式。

iv.  找到可證明公式後，與 An 及 Bn 比較，
     若與 An 一樣則印出 1，
     若與 Bn 一樣則印出 0。
     若不同於 An 及 Bn 則回到 iii，再找下一個可證明的公式。

由上述建構可知 Kα 終究會停止，
故其為 circle-free 機器且 α 為可計算之數列。

可以證明若數字 α 能以上述之公理定義，則 α 可計算，
只要能將計算機之定義利用函數計算即可描述。

不是所有可定義之函數均為可計算數，
由節 8 定義 δ 對角數，則不可計算。

定義整數可計算函數
------------------

整數可計算函數是指一個可計算函數其參數為整數。

γ
..

令 γ 為可計算數列。

n
..

n 為整數。

ξ(γ,n)
......

令 ξ(γ,n) 為 γ 中第 n 個 0 至第 n+1 個 0 中數字 1 的個數。

26.4.φ(n)

φ(n) = ξ(γ,n) 

H(x,y)
......

H(x,y) <-> φ(x) = y

Aφ
..

可以找出一無予盾之公理 Aφ 
滿足 Aφ -> P。

對每個整數 n ，存在一數 N 使得

Aφ & F^(N)  ->  H( u^n, u^φ(n) )

對每個 m <> φ(n) 存在一數 N' 使得  

Aφ & F^(N') -> -H( u^n, u^m    )

由此公理之建構，可知 φ(n) 為可計算之整數函數。

定義可計算變數可計算函數
------------------------

γn
..

設 n 為滿足數，
則 γn 為 M(n) 所計算之數列。

an
..

an = tan(π(γn - 1/2)) | γn <> 0 or 1
     0                | γn == 0 or 1    

φ(n)
....

任何引數 n 若是滿足數，則其值也為滿足數。

雖然不存在通用程序去判斷給定數字 n 是否為滿足數，
但是存在某些方法去判斷某類數均為滿足數。

f
..

f(an) = aφ(n)

可計算數之定理
--------------

一個整數或可計算數之可計算函數之可計算函數是可計算的。

前鎮 20130309 週六 

任何整數函數若以可計算函數作遞迴定義是可計算的。
若φ(m, n) 是可計算的，則 η 是可計算的。

η(0) = r,
η(n) = φ(n, η(n-1)).

令 H(x, y   ) <->  η(x)    = y
   K(x, y, z) <->  φ(x, y) = z

因為 φ 是可計算的，存在一公理 Aφ 來定義 φ。

可用 Aφ 來定義 Uη 如下：

Aφ & P & (F(x,y)                     ->  G(x,y    )) 
       & (G(x,y) & G(y,z)            ->  G(x,z    )) 
       & (F^(r)                      ->  H(u,u^(r))) -- η(0) = r, u 為 0 
       & (F(v,w) & H(v,x) & K(w,x,z) ->  H(w,z    )) -- η(n) = φ(n, η(n-1))
       & (H(w,z) & G(z,t) | G(t,z)   -> -H(w,t    ))

存在數 n 及 N 使得

Aη & F^(N) -> H(u^(n-1), u^(η(n-1)))

存在 M 使得

Uφ & F^(M) -> K(u^(n)  , u^(η(n-1)), u^(η(n)))

Uη & F^(M) -> F(u^(n-1), u^(n)) 
            & H(u^(n-1), u^(η(n-1)))
            & K(u^(n)  , u^(η(n-1), u(η(n))))


η(0) = r
η(n) = φ(n, η(n-1))
     
Entscheidungsproblem
--------------------

20141019 週日 中美

證明大綱：

1.對任一機器 M 可建構公式 Un(M)，其意義為 M 會印出 0。

2.證明引理 1，若 M 會印出 0，則 Un(M) 可證明。

3.證明引理 2，若 Un(M) 可證明，則 M 會印出 0。

4.由引理 1 及 2，
  找到一個通用程序判別 Un(M) 是否可證明等同於找到一個通用程序判別 M 是否會印出 0。

5.設判定問題有解，即是可以找到一個通用程序判別 Un(M) 是否可證明。

6.由定理 3 得知不存在一個機器可以判別任一機器是否會印出 0，
  即不存在通用程序判別 M 是否會印出 0，
  即不存在通用程序判別 Un(M) 是否可證明。

7.6 與 5 不一致，故判定問題無解。

證明：

對任一機器 M 可建構公式 Un(M)，其意義為 M 會印出 0，
即 M 的一些完整描述中，存在 0 於紙帶上。

Un(M) 建構如下：

Un(M) =  (Ex u)A(M) 
      -> (Ex s)(Ex t)RS1(s,t) # 存在完整狀態 s 中第 t 格為 0

20141017 週五   中美路

A(M) 建構如下：

A(M) = 
  Q           # 定義後繼數
& (y)RS0(u,y) # 完整狀態 u 中每格都為空格 
& I(u,u)      # 完整狀態 u 中正掃描到 u 格 
& Kq1(u)      # 初始值
& Des(M)      # M 機之描述

20141018 週六  中美

Q 建構如下：

Q = 
(x)(Ex w)(y,z){ F(x,w) 
              &(F(x,y)          -> G(x,y)) # y 為 x 之直接後繼數 
                                           # 則 y 為 x 之後繼數 
              &(F(x,z) & G(z,y) -> G(x,y)) # z 為 x 之直接後繼數且
                                           # y 為 z 之後繼數
                                           # 則 y 為 x 之後繼數
              &[  G(z,x)           # x 為 z 之後繼數
               v (G(x,y) & G(y,z)) # y 為 x 之後繼數且 z 為 y 之後繼數
               v (F(x,y) & F(z,y)) # y 為 x 及 z 之直接後繼數，
               ->(-F(x,z))         # 上述條件任一滿足則 z 不是 x 之後繼數
               ]
              }

20141018 週六   中美路

Q 主要是定義了 G 這個函數，
G(x,y) 指 y 為 x 之後繼數，
與 F(x,y) 不同的是 y 不是直接後繼數，
x 及 y 之間也可以間隔數個數。

G 之命名應為後繼函數 F 之後的字母。

其中 Des(M) 命名源自 Description-of-M，
為 M 之描述即為 Inst 之合取運算。

原論文誤植為邏輯和(logical sum)，
圖靈於 1938 訂正為合取運算(Conjunction)。

20141018 週六 中美

Inst 建構如下：  

Inst{qi Sj Sk L ql} =  
(x, y, x', y'){ (RSj(x , y )  # 掃描符號為 Sj，
              & I(x, y)       # 掃描頭在 y 格  
              & Kqi(x     )   # 機器狀態為 qi 
              & F(x , x')     # x' = x+1
              & F(y', y )     # y' = y-1
              ->(   I(x', y') # 掃描頭左移一格
                & RSk(x', y ) # 於 y 印出 Sk
                & Kql(x'    ) # 機器狀態轉為 ql 
                & (z)(F(y', z)                   # 完整狀態 x' 除了
                     v[( Rs0(x ,z) -> Rs0(x',z)) # 印出 Sk 那格 y，
                      &( Rs1(x ,z) -> Rs1(x',z)) # 其它格與完整狀態 x 
                      &...                       # 相同
                      &( RsM(x ,z) -> RsM(x',z))
                      ]
                     )

此謂詞描述指令為機器狀態為 qi 、掃描符號為 Sj，
下一步動作為印出 Sk，左移一格後，機器狀態轉為 ql，
Inst{qi Sj Sk R ql}(即右移一格)或
Inst{qi Sj Sk N ql}(不動)
也可以此方式建構出來。

20130215 週五 義仁 

RSi(x,y) 定義為在完整狀態 x 中，紙帶上格 y 的符號是 Si。

I(x,y) 定義為在完整狀態 x 中，正掃描到格 y。

Kqm(x) 定義為在完整狀態 x 中，機器狀態為 qm。

引理 1
......

若 M 會印出 0，則 Un(M) 可證明，
即若 S1 出現在 M 的一些完整狀態中，則 Un(M) 是可證明的。

證明：

先看要如何證明 Un(M)。

CCn 建構如下：

CCn = 
     Rsr(n    ,0      )(u^(n), u    ) # 以下第 n 個完整狀態中
&    Rsr(n    ,1      )(u^(n), u'   ) # 紙帶上之符號
&    ...
&    Rsr(n    ,n      )(u^(n), u^(n))
&      I(u^(n),u(i(n)))               # 掃描格
& Kqk(n)(u^(n))                       # 機器狀態 為 qk(n)
& (y)(   F(y      ,u')                # 紙帶不在 1 至 n 區間
     v   F(u      ,y )                # 均為空格，這是因為
     v   F(u'     ,y )                # 機器只執行 n 步驟，
     v   ...                          # 不會印超出 n 格的符號
     v   F(u^(n-1),y )
     v Rs0(u^(n)  ,y )

CCn 命名源自 n-th Complete Configuration，
指第 n 個完整狀態。

sr(n,y) 定義為第 n 個完整狀態中第 y 格之符號。
i(n)    定義為第 n 個完整狀態中掃描之格。
qk(n)   定義為第 n 個完整狀態之機器狀態。

CC0 = 
  (y)Rs0(u,y) # 初始完整狀態紙帶全為空格
&  I(u,u)     # 初始完整狀態掃描格是第一格 
&  Kq1(u)     # 初始完整狀態機器狀態為 q1

CC0 即是初始完整狀態。

CFn 建構如下：

CFn = A(M) & F^n -> CCn

F^r 定義如下：

F^r = F(u,u')&F(u',u'')&...&F(u^(r-1),u^r) 

以數學歸納法證明對每個 n 而言，CFn 是可證的。

基本步驟：
A(M) -> CC0 是可直接證明，故基本步驟為真。

歸納步驟：
設 CFn 為真，要證明 CF(n+1) 也為真，
即 CFn -> CF(n+1)。

r(n  , i(n)) = b # 完整狀態 n，其掃描符號為 b
r(n+1, i(n)) = d # 完整狀態 n，其印出符號為 d
k(n)         = a # 完整狀態 n  ，其機器狀態為 a
k(n+1)       = c # 完整狀態 n+1，其機器狀態為 c

註：r 之名源自串列之德文 Reihe。

Des(M) 必須包含下面指令，才有上述之完整狀態之轉換。

Des(M) -> Inst{qa Sb Sd L qc}

由上可推出

A(M) & F^(n+1) -> Inst{qa Sb Sd L qc} & F^(n+1)

因為
Inst(qa,Sb,Sd,L,qc) & Q & F^(n+1) -> (CCn -> CCn+1)
是可證的。

所以

A(M) & F^(n+1) -> (CCn -> CCn+1)

且 

(A(M) & F^(n) -> CCn) -> (A(M) & F^(n+1) -> CCn+1)

也就是

CFn -> CFn+1

對每個 n 而言，CFn 是可證的。

A(M) & F^(N) -> CCN

引理 1 假設 S1 出現在 M 的一些完整狀態中，
那表示存在整數 N, K, CCN
包含 Rs1(u^(N), u^(K)) 之項目，
可得 
CCN -> Rs1(u^(N), u^(K))   
是可證明的。

又可得
CCN -> Rs1(u^(N), u^(K)) 且 A(M) & F^(N) -> CCN。

(Ex u)A(M) -> (Ex u)(Ex u')...(Ex u^(N')(a(M) & F^(N)),
其中 N' = max(N, K)。

(Ex u)A(M) -> (Ex u)(Ex u')...(Ex u^(N')Rs1(u^(N), u^(K)) 

(Ex u)A(M) -> (Ex u^(N)(Ex u^(K))Rs1(u^(N), u^(K)) 

(Ex u)A(M) -> (Ex s)(Ex t)Rs1(s, t)

得出 Un(M) 是可證明的。

引理 2
......

20130314 週四 花蓮

若 Un(M) 是可證明的，則 S1 出現在 M 的一些完整狀態中。

證明：

若將可證明公式中的函數變數以命題函數取代，可得一個真的命題。
特別是若我們取代 Un(M) 的函數變數，
可得一個真命題，其意義為 S1出現在 M 的一些完整狀態中。

有效計算是可計算的
------------------

20130319 週二 花蓮 

λ-可定義函數
............

若數列 γ 第 n 個數 φγ(n) 稱作可有效計算或的 λ-可定義，
則存在 1 + φγ(n) 為 n 的 λ-可定義函數，
例如：

存在合式公式(W.F.F) Mγ 對所有的整數　n 

{Mγ}(Nn) -> Nφγ(n)+1 

這指 {Mγ}(Nn) 依據數列 γ 第 n 個數決定轉換成何數，
若數列 γ 第 n 個數是 1 則轉換成 N1，是 0 則轉成 N2。

原文是寫成數列 λ 第 n 個數，也許我是第一個發現此錯誤的人。

邱奇數
......

每個數字可用下列公式表示：

1 -> λab . a(b)
2 -> λab . a(a(b))
3 -> λab . a(a(a(b)))

上述公式分別記成 N1, N2, N3。

證明 λ-可定義數列 γ 是可計算的
..............................

要證明 λ-可定義數列 γ 是可計算的，
同作者一向的作法，要建構一個機器去印出 γ 於紙帶上。

L1 機
.....

L1 機是一台選擇機，
給定一個合式公式 M，會產出任何 M 能轉換的公式。

L2 機
.....

L2 機是一台自動機，
會接續列舉所有 M 能轉換的公式。

L 機
....

L 機分成階段來執行計算。

第 n 個階段會先建構公式 

{Mγ}{(Nn)

此公式再轉給 L2 機，
接續列舉所有 {Mγ}{(Nn) 能轉換的公式。

再將列舉的公式與
N2 (即λx[λx'[{x}({x}(x'))]]) 比較，
若相同則 L 印出 1，並結束第 n 個階段。

再與 N1 比較，若相同則印出 0，並結束第 n 個階段。

若都不同則交由 L2 再列舉下一個可轉換之公式。

由假設 {Mγ}(Nn) 最終會轉換成 N1，或是 N2。
這表示第 n 個階段終會結束，
故 L 機會印出 γ 於紙帶上。

證明可計算的數列 γ 是λ-可定義的
...............................

同上存在合式公式(W.F.F) Mγ 對所有的整數　n 

{Mγ}(Nn) -> Nφγ(n)+1 

這指 {Mγ}(Nn) 依據數列 γ 第 n 個數決定轉換成何數，
若數列 γ 第 n 個數是 1 則轉換成 N1，是 0 則轉成 N2。

令 M 機計算出 γ。

ξ(n) 
....

令 ξ(n) 表示 M 的第 n 個完整狀態之描述數。 

ργ
..

ργ 會將輸入的完整狀態，轉為下一個完整狀態。

ξ(n+1) = ργ(ξ(n))

圖靈省略對 ργ 是 λ-可定義之證明。

Aγ
..

因為 ργ 是 λ-可定義，
故存在合式公式 Aγ 對所有整數 n 可得

{Aγ}(Nξ(n)) -> Nξ(n+1)

Uγ
..

令 Uγ 表示下列合式公式：

λu[{{u}(Aγ)}(Nr)]

其中 r = ξ(0)

則對所有整數 n

{Uγ}(Nn) -> Nξ(n)

我的證明：

   {Uγ}(N3) 
-> {{N3}(Aγ)}(Nr) 
-> {{λx[λx'[{x}({x}({x}(x')))]}(Aγ)}(Nr) 
-> {[λx'[{Aγ}({Aγ}({Aγ}(x')))]}(Nr) 
-> {Aγ}({Aγ}({Aγ}(Nr)))
-> {Aγ}({Aγ}(Nξ(1)))
-> {Aγ}(Nξ(2))
-> Nξ(3)

V
..

可建構公式 V 判定第 n 個完整狀態轉換至第 n+1 個完整狀態，
是否會印出 1 或 0。

{{V}(Nξ(n+1))}Nξ(n) -> N1 | 第 n 個完整狀態轉換至第 n+1 個完整狀態，
                            會印出 0。 
                    -> N2 | 會印出 1。
                    -> N3 | 其它情形。

命名源自判定書的英文(verdict)。

Wγ
..

Wγ 接受一個整數公式 Nn，判定第 n 個完整狀態轉換至第 n+1 個完整狀態，
是否會印出 1 或 0。

Wγ := λu[{{v}({Aγ}({Uγ}u))}({Uγ}u)

由上可得對每個整數 n 都可得，

{{V}(Nξ(n+1))}Nξ(n) -> {Wγ}Nn 

Q
..

可建構公式 Q 接受 Ns，
並傳回數列 γ 第 s 個數之公式。

{{Q}(Wγ)}(Ns) -> Nr(s)

其中 r(s) 是數列 γ 第 s 個數 q，
這樣 {Wγ}Nq 便可判定轉成 N1 或 N2。

Mγ
..

這指 {Mγ}(Nn) 依據數列 γ 第 n 個數決定轉換成何數，
若數列 γ 第 n 個數是 1 則轉換成 N1，是 0 則轉成 N2。

可建構 Mγ 如下：

Mγ := λw[{Wγ}({{Q}(Wγ)}(w))]
